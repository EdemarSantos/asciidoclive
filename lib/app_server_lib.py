# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                         Copyright (C) 2014 Chuan Ji                         #
#                             All Rights Reserved                             #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
"""Main web app server library."""

import flask
import flask.ext.mongoengine
import json

from lib import asciidoc_lib
from lib import env_lib


# The WSGI app object.
# pylint: disable=invalid-name
app = flask.Flask(
    __name__,
    template_folder=env_lib.TEMPLATES_DIR,
    static_folder=env_lib.STATIC_DIR)
app.config.update(
    MONGODB_SETTINGS={
        'DB': env_lib.DB_NAME,
    })
env_lib.DB.init_app(app)
# pylint: enable=invalid-name


@app.route('/')
def RenderEditor():
  """Handler for the main editor page."""
  if '_escaped_fragment_' in flask.request.args:
    # Static version for search engine crawlers.
    template = 'static.html'
  else:
    template = 'editor.html'
  return flask.render_template(template)


@app.route('/api/v1/asciidoc-to-html', methods=['POST'])
def AsciiDocToHtml():
  """Handler for AsciiDoc to HTML conversion.

  POST arguments:
    - text: the text to convert.
  Returns:
    A JSON dict of the form:
        {
          'success': <A boolean indicating whether the conversion succeeded.>
          'html': <HTML generated by AsciiDoc>
          'error_message': <Warnings or error messages>
        }
  """
  text = flask.request.form.get('text', '')
  if len(text) > env_lib.MAX_SOURCE_TEXT_SIZE:
    response = {
        'success': False,
        'html': '',
        'error_message': 'Maximum text size exceeded.',
    }
  else:
    (return_code, stdout_output, stderr_output) = (
        asciidoc_lib.GetAsciiDocResult(text))
    response = {
        'success': return_code == 0,
        'html': stdout_output,
        'error_message': stderr_output,
    }
  return json.dumps(response)
