# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                         Copyright (C) 2014 Chuan Ji                         #
#                             All Rights Reserved                             #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
"""Main web app server library."""

import flask
from flask.ext import login
import json

from lib import auth_lib
from lib import asciidoc_lib
from lib import env_lib


# The WSGI app object.
# pylint: disable=invalid-name
app = flask.Flask(
    __name__,
    template_folder=env_lib.TEMPLATES_DIR,
    static_folder=env_lib.STATIC_DIR)
app.config.from_object(env_lib.CONFIG)
env_lib.DB.init_app(app)
env_lib.LOGIN_MANAGER.init_app(app)
# pylint: enable=invalid-name


def _RenderTemplate(template, extra_args=None):
  """Renders a template with the default args and optional extra args."""
  args = {
      'user': login.current_user,
  }
  if extra_args:
    args.update(extra_args)
  return flask.render_template(template, **args)


@app.route('/')
def RenderEditor():
  """Handler for the main editor page."""
  if '_escaped_fragment_' in flask.request.args:
    # Static version for search engine crawlers.
    template = 'static.html'
  else:
    template = 'editor.html'
  return _RenderTemplate(template)


@app.route('/sitemap.xml')
def RenderSitemap():
  """Handler for a sitemap request."""
  return _RenderTemplate('sitemap.xml')


@app.route('/api/v1/asciidoc-to-html', methods=['POST'])
def AsciiDocToHtml():
  """Handler for AsciiDoc to HTML conversion.

  POST data: A JSON object:
    - text: the text to convert.
  Returns:
    A JSON dict of the form:
        {
          'success': <A boolean>
          'html': <HTML generated by AsciiDoc>
          'error_message': <Warnings or error messages>
        }
  """
  request_data = flask.request.get_json()
  if 'text' not in request_data:
    response = {
        'success': False,
        'html': '',
        'error_message': 'Invalid request',
    }
  elif len(request_data['text']) > env_lib.MAX_SOURCE_TEXT_SIZE:
    response = {
        'success': False,
        'html': '',
        'error_message': 'Maximum text size exceeded.',
    }
  else:
    (return_code, stdout_output, stderr_output) = (
        asciidoc_lib.GetAsciiDocResult(request_data['text']))
    response = {
        'success': return_code == 0,
        'html': stdout_output,
        'error_message': stderr_output,
    }
  return json.dumps(response)


@app.route('/api/v1/auth', methods=['POST'])
def Auth():
  """Handler for user authentication.

  This is invoked by the client side after a successful login.

  POST data: a JSON object:
    - accounts: an array of objects:
      - account_provider_type: type of the account provider.
      - user_id: the user's ID with the account provider.
      - auth_token: the authentication token obtained from the provider.
  Returns:
    A JSON dict of the form:
        {
          'success': <A boolean>
          'user_id': <Our very own user ID>
          'error_message': <Warnings or error messages>
        }
  """
  response = None
  request_data = flask.request.get_json()
  if ('accounts' not in request_data or
      not isinstance(request_data['accounts'], list) or
      not request_data['accounts']):
    response = {
        'success': False,
        'error_message': 'Invalid request',
    }
  else:
    accounts = []
    for account_data in request_data['accounts']:
      if (not account_data.get('account_provider_type', None) or
          not account_data.get('user_id', None) or
          not account_data.get('auth_token', None) or
          account_data['account_provider_type'] not in
          auth_lib.ACCOUNT_PROVIDERS):
        response = {
            'success': False,
            'error_message': 'Invalid request',
        }
        break
      account_provider = (
          auth_lib.ACCOUNT_PROVIDERS[account_data['account_provider_type']])
      if not account_provider.IsTokenValid(
          account_data['user_id'], account_data['auth_token']):
        response = {
            'success': False,
            'error_message': 'Invalid token',
        }
        break
      else:
        accounts.append(
            (account_data['account_provider_type'], account_data['user_id']))
    if response is None:
      # All accounts valid.
      user = auth_lib.FindOrCreateUser(accounts)
      response = {
          'success': True,
          'user_id': user.user_id,
          'error_message': ''
      }
      login.login_user(user, remember=True)

  return json.dumps(response)


@app.route('/api/v1/logout', methods=['POST'])
def Logout():
  """Handler for user logout.

  POST data: an empty JSON object.
  Returns:
    A JSON dict of the form:
        {
          'success': <A boolean>
          'error_message': <Warnings or error messages>
        }
  """
  if login.current_user.is_authenticated():
    login.logout_user()
    response = {
        'success': True,
        'error_message': '',
    }
  else:
    response = {
        'success': False,
        'error_message': 'Not authenticated',
    }
  return json.dumps(response)


@app.route('/api/v1/auth_state_change_refresh', methods=['POST'])
def AuthStateChangeRefresh():
  """Re-renders elements that depend on authentication state.

  This will return HTML strings based on the current authentication state.

  POST data: None.
  Returns:
    A JSON dict of the form:
        {
          'success': <A boolean>
          'header': <Re-rendered header div>
        }
  """
  response = {
      'success': True,
      'header': _RenderTemplate('header.html'),
  }
  return json.dumps(response)
